{{< include ../_setup.qmd >}}

# Input Data

## Data Process Checks

::: panel-tabset

### Home Improvement Exemption Spot Check

This tests if our Home Improvement Exemption characteristics are getting
accurately updated.

```{r _input_hie_characteristics}
input_hie_pins <- training_data %>%
  filter(
    hie_num_active == 1,
    meta_triad_code == run_triad_code,
    meta_year == as.numeric(metadata$assessment_data_year)
  ) %>%
  pull(meta_pin) %>%
  unique()

input_hie_chars_df <- chars_data %>%
  filter(
    meta_year == as.numeric(metadata$assessment_data_year),
    meta_pin %in% input_hie_pins
  ) %>%
  inner_join(
    hie_data %>%
      filter(
        pin %in% input_hie_pins,
        year >= as.numeric(metadata$assessment_data_year) - 4,
        qu_sqft_bld > 0
      ) %>%
      select(-year),
    by = join_by(meta_pin == pin)
  ) %>%
  left_join(
    training_data %>% select(
      meta_pin, meta_year,
      train_sqft = char_bldg_sf,
      train_fbath = char_fbath, train_air = char_air
    ),
    by = join_by(meta_pin, meta_year)
  ) %>%
  select(
    PIN = meta_pin,
    `OG SQFT` = char_bldg_sf,
    `HIE SQFT` = qu_sqft_bld,
    `NEW SQFT` = train_sqft,
    `OG FBATH` = char_fbath,
    `HIE FBATH` = qu_full_bath,
    `NEW FBATH` = train_fbath,
    `OG AIR` = char_air,
    `HIE AIR` = qu_air,
    `NEW AIR` = train_air
  )

input_hie_chars_df %>%
  datatable(rownames = FALSE)
```

### Characteristic Filling

This tests if our time filling techniques are working as expected.

```{r _input_characteristic_filling}
input_char_filling_df <- training_data %>%
  filter(
    !ind_pin_is_multicard,
    min(meta_sale_date) < lubridate::make_date(as.numeric(metadata$input_max_sale_year) - 3),
    max(meta_sale_date) > lubridate::make_date(as.numeric(metadata$input_max_sale_year) - 3),
    .by = meta_pin
  ) %>%
  filter(n() > 6, .by = meta_pin) %>%
  select(
    PIN = meta_pin,
    Year = meta_year,
    `Sale Date` = meta_sale_date,
    `FS Flood Factor (2019)` = loc_env_flood_fs_factor,
    `Walkability (2017)` = loc_access_cmap_walk_total_score,
    `GS Rating (2021)` = prox_avg_school_rating_in_half_mile
  ) %>%
  arrange(PIN, Year)

input_char_filling_df %>%
  datatable(rownames = FALSE)
```

### Multi-Card and Multi-PIN Aggregation

This uses 5 test pins to assess if multi-card parcels successfully aggregate to
the full pin.

```{r _input_multicard_sample}
input_multicard_test_pins <- c(
  "17321110470000",
  "05174150240000",
  "05213220250000",
  "08121220400000",
  "06334030310000"
)

input_multicard_test_df <- assessment_card %>%
  filter(meta_pin %in% input_multicard_test_pins) %>%
  arrange(meta_pin, meta_card_num) %>%
  select(
    PIN = meta_pin, Class = meta_class, Card = meta_card_num,
    `Card %` = meta_card_pct_total_fmv, SQFT = char_bldg_sf,
    `Card Initial` = pred_card_initial_fmv,
    `Card Final` = pred_card_final_fmv
  ) %>%
  left_join(
    assessment_pin %>%
      select(
        PIN = meta_pin, Proration = meta_tieback_proration_rate,
        `PIN Far` = prior_far_tot,
        `PIN Near` = prior_near_tot,
        `PIN Initial` = pred_pin_initial_fmv,
        `PIN Final` = pred_pin_final_fmv_round
      ),
    by = c("PIN")
  ) %>%
  mutate(
    `Card %` = scales::percent(`Card %`, accuracy = 0.01),
    `SQFT` = scales::comma(`SQFT`),
    `Card Initial` = scales::dollar(`Card Initial`),
    across(starts_with("PIN "), scales::dollar)
  )

input_multicard_test_df %>%
  datatable(rownames = FALSE)
```

### Land Valuation

```{r, _input_land_valuation, out.width="100%"}
input_land_valuation <- assessment_pin %>%
  filter(meta_triad_code == run_triad_code) %>%
  mutate(land_pct = pred_pin_final_fmv_land / pred_pin_final_fmv_round) %>%
  select(
    meta_pin,
    land_pct,
    pred_pin_final_fmv_bldg,
    pred_pin_final_fmv_land,
    pred_pin_final_fmv_round
  )

input_land_valuation %>%
  ggplot() +
  geom_histogram(aes(x = land_pct)) +
  scale_x_continuous(
    name = "Land % of Total FMV",
    labels = scales::label_percent()
  ) +
  labs(y = "Count") +
  theme_minimal()
```

### PINs with 0 or Missing Land Values

```{r _input_pins_weird_land}
assessment_pin %>%
  filter(meta_triad_code == run_triad_code) %>%
  filter(
    pred_pin_final_fmv_land == 0 |
      is.infinite(pred_pin_final_fmv_land / pred_pin_final_fmv_round) |
      is.na(pred_pin_final_fmv_land / pred_pin_final_fmv_round)
  ) %>%
  mutate(township_name = ccao::town_convert(meta_township_code)) %>%
  select(
    `Year` = meta_year,
    `Township Name` = township_name,
    `PIN` = meta_pin,
    `Class` = meta_class,
    `Land %` = pred_pin_final_fmv_land / pred_pin_final_fmv_round,
    `Land FMV` = pred_pin_final_fmv_land,
    `Land Sqft.` = char_land_sf
  ) %>%
  datatable(rownames = FALSE)
```

:::

## Multi-Family and Townhomes

::: panel-tabset

### Multi-family YoY Changes

Where are 211s and 212s increasing a *lot*? Near values are Certified values
from the current year, and far values are Board of Review values from two years ago.

```{r _input_211_and_212_yoy_changes}
input_multifamily_change <- assessment_pin %>%
  filter(
    meta_class %in% c("211", "212"),
    meta_triad_code == run_triad_code
  ) %>%
  mutate(
    yoy_far = abs((pred_pin_final_fmv - prior_far_tot) / pred_pin_final_fmv),
    yoy_near = abs((pred_pin_final_fmv - prior_near_tot) / pred_pin_final_fmv),
    big_swing_near = yoy_near > 0.5,
    big_swing_far = yoy_far > 0.5
  ) %>%
  summarise(
    big_swings_near = sum(as.numeric(big_swing_near), na.rm = TRUE) / n(),
    big_swings_far = sum(as.numeric(big_swing_far), na.rm = TRUE) / n(),
    .by = c(meta_township_code, meta_class)
  ) %>%
  arrange(desc(big_swings_near)) %>%
  mutate(across(starts_with("big"), ~ label_percent(accuracy = 0.1)(.x))) %>%
  left_join(
    ccao::town_dict %>%
      select(meta_township_code = township_code, township_name)
  ) %>%
  select(
    "Township Name" = township_name,
    "Class" = meta_class,
    "% Delta Near > 50%" = big_swings_near,
    "% Delta Far > 50%" = big_swings_far
  )

input_multifamily_change %>%
  datatable(rownames = FALSE)
```

### Large Sqft. 211s and 212s

Table of 211s and 212s which are three standard deviations above the norm in terms of square footage. 

```{r _input_large_211_212}
training_data %>%
  filter(
    meta_class %in% c("211", "212"),
    meta_triad_code == run_triad_code,
    !ind_pin_is_multicard
  ) %>%
  mutate(
    mean_sf = round(mean(char_bldg_sf, na.rm = TRUE), 0),
    outlier = abs(char_bldg_sf) >
      mean(char_bldg_sf, na.rm = TRUE) + 3 * sd(char_bldg_sf, na.rm = TRUE),
    .by = meta_class
  ) %>%
  filter(outlier) %>%
  mutate(across(ends_with("_sf"), scales::comma)) %>%
  select(
    PIN = meta_pin,
    `Township Name` = meta_township_name,
    Class = meta_class,
    `Mean Sqft` = mean_sf,
    `Building Sqft` = char_bldg_sf
  ) %>%
  datatable(rownames = FALSE)
```

### Townhome Complex Averaging

This takes a sample of 20 observations to see how far apart the initial
predicted values are for townhomes. Is the average they get assigned reasonable?

```{r _input_townhomes_210_295}
assessment_pin %>%
  filter(!is.na(meta_complex_id) & meta_triad_code == run_triad_code) %>%
  group_by(meta_complex_id) %>%
  mutate(
    fmvpsf = pred_pin_final_fmv / char_total_bldg_sf
  ) %>%
  summarise(
    n = n(),
    "Min Initial FMV" = min(pred_pin_initial_fmv, na.rm = TRUE),
    "Max Initial FMV" = max(pred_pin_initial_fmv, na.rm = TRUE),
    "Initial % Range" =
      (`Max Initial FMV` - `Min Initial FMV`) / `Min Initial FMV`,
    "Mean Final FMV" = mean(pred_pin_final_fmv, na.rm = TRUE),
    "FMV per SQFT SD" = sd(fmvpsf, na.rm = TRUE)
  ) %>%
  slice_max(order_by = `Initial % Range`, n = 20) %>%
  mutate(
    across(contains("SQFT"), ~ round(.x, 1)),
    across(contains("FMV"), dollar),
    across(contains("%"), ~ percent(.x, accuracy = 0.1))
  ) %>%
  relocate(c(meta_complex_id, n)) %>%
  rename("Complex ID" = meta_complex_id, "Count" = n) %>%
  datatable(rownames = FALSE)
```

### Map of Townhome Complex IDs

```{r _input_complex_id_map, warning=FALSE}
input_complex_id_map <- complex_id_data %>%
  mutate(
    township_name = ccao::town_convert(meta_township_code),
    triad = ccao::town_get_triad(meta_township_code, name = TRUE)
  ) %>%
  mutate(complex_id_cnt = n(), .by = meta_complex_id) %>%
  filter(triad == run_triad, complex_id_cnt >= 6) %>%
  group_by(township_name) %>%
  sample_n(5) %>%
  select(meta_complex_id) %>%
  left_join(complex_id_data, by = "meta_complex_id") %>%
  left_join(
    chars_data %>%
      filter(meta_year == metadata$assessment_data_year) %>%
      select(
        meta_pin,
        loc_longitude,
        loc_latitude,
        char_rooms,
        char_bldg_sf,
        char_yrblt
      ),
    by = "meta_pin"
  )

input_complex_id_palette <- colorFactor(
  palette = "Set1",
  domain = unique(input_complex_id_map$meta_complex_id)
)

leaflet(input_complex_id_map) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(
    ~loc_longitude,
    ~loc_latitude,
    popup = ~ paste0(
      "<b>Complex ID</b> ", as.character(meta_complex_id),
      "<hr>",
      "<b>Rooms</b>: ", char_rooms,
      "<br><b>Building SF</b>: ", scales::comma(char_bldg_sf),
      "<br><b>Year Built</b>: ", char_yrblt
    ),
    radius = 5,
    weight = 1,
    color = ~ input_complex_id_palette(meta_complex_id),
    opacity = 1,
    fillColor = ~ input_complex_id_palette(meta_complex_id),
    fillOpacity = 1
  )
```

:::
