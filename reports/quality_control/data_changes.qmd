

```{r}
#| cache: true
#| cache-extra: !expr rlang::hash(params)
#| cache-file-1: !expr rlang::hash_file("_baseline_query_data.R")
#| cache-file-2: !expr rlang::hash_file("_utils.R")
```


```{r _data_changes_setup_script}
source("_baseline_query_data.R")
```

# Changed Values by Year

```{r}
# tolerance list:

# Many of our features shouild be exact matches but are not. For example,
# our distance to features have some minor variation due to geocoding variance.
# Because of this, all distance features have a buffer of 5 feet.
# There are also features which should not match, but we want to make sure that
# they stay relatively stable. For example, the percentage of college educated
# individuals should not change by more than 5% year over year.
get_tolerance <- function(nm) {
  base_tolerance <- c(
    year = 1,
    loc_longitude = 0.0001,
    loc_latitude = 0.0001,
    prox_num_foreclosure_per_1000_pin_past_5_years = 5,
    other_tax_bill_rate = 0.5,
    ccao_n_years_exe_homeowner = 1,
    acs5_median_household_renter_occupied_gross_rent = 400,
    acs5_median_age_total = 5,
    acs5_median_income_household_past_year = 5000,
    acs5_median_income_per_capita_past_year = 5000,
    acs5_median_household_total_occupied_year_built = 5,
    time_sale_year = 1,
    time_sale_day = 31,
    time_sale_day_of_week = 7
  )

  # Distance features have a 5 ft buffer
  if (grepl("dist_ft$", nm)) {
    return(5)
  }

  # Percentage features have a 5% buffer
  if (grepl("^acs5_percent_", nm)) {
    return(0.05)
  }
  if (nm %in% names(base_tolerance)) {
    return(base_tolerance[[nm]])
  }
  0
}

match_with_buffer <- function(x, colname) {
  # Convert universally to character to make sure nothing changes over time
  vals_chr <- trimws(as.character(x))

  tolerance <- get_tolerance(colname)

  # Try numeric tolerance for those which we use a tolerance
  # otherwise exact match.
  vals_num <- suppressWarnings(as.numeric(vals_chr))
  if (all(!is.na(vals_num))) {
    return((max(vals_num) - min(vals_num)) <= tolerance)
  } else {
    return(length(unique(tolower(vals_chr))) <= 1)
  }
}

# -------------------- PIPELINE --------------------
card_data <- rbind(comp_chars, baseline_chars)
dt <- as.data.table(card_data)[order(meta_pin, meta_card_num)]
setnames(dt, "meta_year", "year")

key_cols <- c("meta_pin", "meta_card_num")
cols <- setdiff(names(dt), key_cols)

# Tolerance checks once ---
group_matches <- dt[
  , Map(function(col, nm) match_with_buffer(col, nm), .SD, names(.SD)),
  by = key_cols, .SDcols = cols
]

# Long form of match flags (used by BOTH outputs)
gm_long <- melt(
  as.data.table(group_matches),
  id.vars = key_cols,
  variable.name = "column",
  value.name = "is_match"
)

# Count of NOT matching values
count_not_matching <- gm_long[is_match == FALSE,
  .(Count = .N),
  by = .(Column = column)
][order(-Count)]
```

::: {.panel-tabset}

## Count of Unmatched Values
```{r}
DT::datatable(
  count_not_matching,
  options = list(
    scrollY = "300px",
    scrollX = TRUE,
    paging = TRUE,
    pageLength = 100,
    searching = TRUE
  ),
  rownames = FALSE
)

# Unmatched values by year (only FAILED triples) ---
# Long form of values once (shared)
dt_long <- melt(
  dt,
  id.vars = c(key_cols, "year"),
  measure.vars = cols,
  variable.name = "column",
  value.name = "value"
)

# Keys that failed tolerance
unmatched_idx <- gm_long[is_match == FALSE, .(meta_pin, meta_card_num, column)]

# Keep values only for failed triples
unmatched_values_long <- merge(
  dt_long, unmatched_idx,
  by = c("meta_pin", "meta_card_num", "column"),
  all = FALSE
)

# Wide with year-suffixed columns
unmatched_wide <- dcast(
  unmatched_values_long,
  meta_pin + meta_card_num ~ column + year,
  value.var = "value",
  sep = "_"
)

# Sample for readability
if (nrow(unmatched_wide) > 10000) {
  unmatched_wide <- unmatched_wide[sample(.N, 10000)]
}
```
## Card Level Changes

```{r}
DT::datatable(
  unmatched_wide,
  extensions = "Scroller",
  options = list(
    deferRender = TRUE,
    scrollY = 400,
    scroller = TRUE,
    scrollX = TRUE,
    paging = TRUE,
    pageLength = 100,
    lengthMenu = c(10, 25, 50, 100),
    searching = TRUE
  ),
  rownames = FALSE
)
```
:::
